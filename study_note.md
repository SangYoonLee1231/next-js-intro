### 2.0 Introduction

- NextJS는 프레임워크이다.

- NextJS는 실행시 app 폴더와 page.tsx 파일을 참조하지만, 동시에 layout.tsx 파일도 확인한다. (layout.tsx 파일이 없으면 자동으로 생성된다)

<br/>

### 2.1 Defining Routes

- NextJS는 파일 시스템을 통해서 url을 표현한다.

- `root segment`: `app` 폴더의 가장 바깥쪽 영역으로 NextJS가 가장 먼저 참고하는 페이지가 있는 영역

- 폴더명이 잠재적으로 하나의 페이지가 될 수 있다.

  - `/about-us` url을 가진 페이지를 생성하려면..  
    `app` 폴더 내에 `about-us` 폴더를 만든 후, 그 안에 `page.tsx` 파일 생성해 UI 코드를 넣으면 된다.

- 폴더는 그저 경로일 뿐, 그 안에 `page.tsx` 파일이 있어야 해당 경로에 실제로 화면을 보여준다.

- 폴더를 중첩하면 중첩 라우팅이 가능하다.

  - `about-us/company/sales` 경로로 화면을 볼려면, `about-us/company/sales/page.tsx` 파일을 만들어 UI 코드를 넣어주면 된다.

<br/>

### 2.2 Not Found Routes

- not found 페이지

  - 잘못된 경로를 처리

- page, layout, not-found은 특별한 이름을 가진 파일

- Navigation Bar 만들기

- usePathname

  - usePathname은 client components에서만 작동

  - 파일 상단에 "use client"를 적어주면 사용 가능 (이유는 다음에 살펴봄)

<br/>

### 2.3 SSR vs CSR

- usePathname은 client components에서만 작동한다.

- next.js가 application을 render하는 방식

  - rendering: next.js가 우리의 react component를 가져와서 브라우저가 이해할 수 있는 html로 변환하는 작업을 말함

- CSR (Client Side Rendering)

  - 클라이언트에서 랜더링을 진행

  - 페이지 로딩 시 자바스크립트를 로드하는 시간이 필요

  - 빈 페이지에서 시작하므로 SEO에 불리

- SSR (Server Side Rendering)

  - 모든 page 안의 모든 component들은 우선 서버에서 렌더링 됨

  - 따라서 클라이언트에는 (서버로부터 받은) 이미 랜더링된 HTML 코드가 존재

- React - CSR | NextJS - SSR

- "use client"를 적어도, 해당 파일이 클라인트에서 랜더링 된다는 의미가 아니다.

<br/>

### 2.4 Hydration

- 사용자가 최초 HTML을 본 뒤에 어떤 일이 발생하는지, React가 언제 활성화되는지 등을 알아본다.

- 사용자가 페이지에 도착하는 즉시, 프레임워크는 load를 시작한다.

- 그리고 지루한 HTML에다가 새로운 React Application을 초기화한다. (인터렉티브하게 바뀜)

- Hydration은 SSR통해 만들어진 단순 HTML을 (클라이언트에서) React Application으로 초기화하는 작업이다.

  - Hydration = 수분 보충

<br/>

### 2.5 'use client'

- NextJS은 응답하기 전에 서버에서 모든 page와 component를 render (초기 상태에서 render) -> HTML로 만들어서 클라이언트로 건네줌 -> 그리고 뒷단에서 프레임워크가 초기화되고 -> 초기 HTML의 위에 React Application을 생성 (정적이었던 HTML 페이지가 동적이고 인터렉티브하게 바뀜)

- 여기서 하나 빠진 내용은 클라이언트에서의 이 Hydration 과정이 모든 component에 대해 발생하지는 않는다는 것이다.

- 오직 "use client" 지시어를 맨 위에 가지고 있는 component만 Hydration 과정이 진행된다.

- "use client" : Backend에서 render되고, Frontend에서 hydrated됨을 의미

- Server Component: 'use client'을 사용하지 않아 hydrate되지 않는 컴포넌트를 의미 (Client Component는 반대 의미)

- Server Component와 관련된 JavaScript 코드는 다운받을 필요가 없음

  - 다운로드할 JS 코드 수 감소 -> 페이지 로딩 속도 향상

<br/>

### 2.7 Layouts

- 모든 컴포넌트에 들어갈 UI를 위해 레이아웃 시스템이 필요하다.

- 실제로 NextJS는 먼저 layout.tsx의 layout component로 먼저 가서, 이 컴포넌트에 있는 export된 디폴트 컴포넌트를 렌더링한다.

- Layout 컴포넌트 안에 URL로 인식한 페이지 컴포넌트가 들어간다.

- 레이아웃은 중첩된다. 하위 폴더의 모든 페이지에도 적용된다.

```ts
import Navigation from "../components/navigation";

export const metadata = {
  title: "Next.js",
  description: "Generated by Next.js",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <Navigation />
        {children}
      </body>
    </html>
  );
}
```

<br/>

### 2.8 Metadata

- metadata와 route groups에 대해 학습한다.

- 이번 영상에서는 route groups을 사용하여 route들을 정리하는 방법에 대해 배운다.

- app 폴더 하위에 `(home)` 폴더를 만들어 app/page.tsx를 이 곳에 넣어준다.

- 괄호로 묶어진 폴더는 URL에 영향을 미치지 않는다.

- metadata는 꼭 내보내야 하는 object

  ```ts
  export const metadata = {
    title: "Next.js",
    description: "Generated by Next.js",
  };
  ```

- metadata는 꼭 layout.tsx 파일에만 있을 필요는 없으며, layout과 마찬가지로 중첩된다. 실제로는 메타데이터는 병합된다.

- 페이지나 레이아웃만 메타데이터를 내보낼 수 있다는 것을 꼭 기억하자.

- 또한, metadata는 서버 컴포넌트에서만 존재할 수 있다. client 컴포넌트에는 있을 수 없다.

- metadata 코드를 재사용할 수 있는 방법

```ts
// app/layout.tsx

// ...

export const metadata: Metadata = {
  title: {
    template: "%s | Next Movies",
    default: "Loading...",
  },
  description: "The best movies on the best framework",
};

// ...
```

<br/>
